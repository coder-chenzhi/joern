DDG (Data Dependency Graph)
数据依赖图包含“使用——定义链”和“定义——使用链”，
先识别所有的变量定义与使用，然后根据到达定值的传递方程，利用到达定值的迭代算法计算得出（Reaching Definitions）。
先从ControlFlowGraph得到UseDefGraph，再从UseDefGraph与ControlFlowGraph得到DefUseGraph，
最后从DefUseGraph得到DDG

使用——定义链是包含了一个变量的使用U和其所有定义D的数据结构。其中D是不经过任何对该变量的赋值干扰就可以抵达使用U的定义点。

定义——使用链是包含了一个变量的定义D和其所有使用U的数据结构。其中D是不经过任何对该变量的赋值干扰就可以抵达所有的使用U的定义点。

这里我们说的一个变量定义D指的是对该变量的赋值语句，使用U指的是使用了该变量的语句。   

要生成使用——定义链和定义——使用链，首先要计算出所有的变量标识符以及使用它们的语句。
第一，需要找到控制流图中的变量标识符。变量标识符的查找在语法树上进行，采用深度优先的方式。
通过栈记录孩子结点的父亲。孩子结点上发现的标识符会沿着语法树向上传播到祖先结点。
标识符的生产源有三个：单操作符运算，普通成员访问操作，指针成员访问。这三个来源都属于表达式类型。 
第二，根据语句类型和该变量在语句中的位置来确定一个语句是对该变量标识符的“定义”，还是“使用”了该变量标识符。
在进行解析时，通过构建语法单元的类继承体系，将产生“定义”的语法结点与产生“使用”的语法结点进行区分，
可以很好地分离各自对标识符的“定义”和“使用”的判断。  

经过上述两步，我们计算出了标识符变量的“使用”和“定义”，但是却不知道他们在控制流上的先后顺序和复写传播关系，
而且这里计算出来的“使用”和“定义”是语法树上的语法单元，并不一定是控制流图上的点(控制流图上的点一定是语句结点)。 
将上述变量标识符到语法结点集的映射表，转换为以在控制流结点为键，以其所使用或者定义的标识符的集合为值的映射表。 
这里得到的控制流图上的点至其使用或定义的变量标识符的映射表还并不是前文提到的使用——定义链，或者定义——使用链。
由于二者的等价性，这里只讨论定义使用链的计算方法。  

为了记录控制流图上结点的先驱和后继关系，我们构造从后继结点到前驱结点以及前驱结点到后继结点的双向映射速查表。
将带有控制流前驱后继双向映射速查表、控制流结点到其定义标识符集合的映射表、控制流结点到其使用标识符集合映射表
的控制流图称为DefUseCFG。有了DefUseCFG根据到达定值传递方程和迭代算法，就可以计算出每一个控制流结点的到达定值了。 
迭代算法帮助我们找到控制流图中每个语句的REACHin和REACHout，而之前的DefUseGraph让我们可以方便地查找一个语句所使用的标识符。
这样，在DefUseGraph中查找该控制流结点的标识符使用表，如果表中可以查到REACHin中的语句所定义的符号，
说明两个控制流结点(定义语句到当前控制流语句)存在对该标识符的数据依赖。
这就得到了使用——定义链。通过增加关联“使用”和“定义”的边，来构造数据依赖图(DDG)。 